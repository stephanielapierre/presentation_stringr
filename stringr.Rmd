---
title: "STRINGR"
subtitle: "Un package de TIDYVERSE"  
author: 
  - "par Stéphanie Lapierre"
date: '23 novembre 2021'
output:
  xaringan::moon_reader:
    css: xaringan-themer-2.css
    nature:
      slideNumberFormat: "%current%"
      highlightStyle: github
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: true

---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
  fig.width=9, fig.height=3.5, fig.retina=3,
  out.width = "100%",
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  hiline = TRUE
)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
  style_duo_accent(
    primary_color = "#6212AF",
    secondary_color = "#BCF308",
    inverse_header_color = "#FFFFFF"
  )

library(tidyverse)

# install package
# install.packages("titanic")
library(titanic)
df <- titanic_train
```

class: center, middle


<center><img src="https://d33wubrfki0l68.cloudfront.net/45fd04ad9cdb2159fea08d07dbc11e742d68e4e3/df327/css/images/hex/stringr.png" height="350px" /></center>


### « Strings are not glamorous, high-profile components of R, but they do play a big role in many data cleaning and preparation tasks. » 
[stringr, tidyverse](https://stringr.tidyverse.org/)

---
## Chaîne de caractère

Selon GeeksforGeeks 

> Les chaînes de caractères (_string_) sont essentiellement un ensemble de caractères. Un ou plusieurs caractères inclus dans une paire de guillemets simples ou doubles correspondants peuvent être considérés comme une chaîne de caractères dans R. Les chaînes représentent un contenu textuel et peuvent contenir des nombres, des espaces et des caractères spéciaux.  [(Tranduction libre)](https://www.geeksforgeeks.org/r-strings/)

<br /> 

```{r eval=FALSE}

string <- "Voici une chaîne de charactère"
```

<br /> 

```{r eval=FALSE}

string2 <- 'Si on inclut une "citation", on utilise les guillemets simples.'
```

---
background-image: url(https://d33wubrfki0l68.cloudfront.net/45fd04ad9cdb2159fea08d07dbc11e742d68e4e3/df327/css/images/hex/stringr.png)
background-position: 1050px 50px
background-size: 80px

## stringr

#### Un *package* de Tidyverse
Le *package stringr* fournit un ensemble de fonctions pour faciliter le travail avec les chaînes de caractères. Bâti à partir de *stringi*, *stringr* offre les fonctions les plus importantes et les plus utilisées pour manipuler les chaînes de caractères.

<br /> 

#### Astuce
Si aucune fonction de *stringr* ne répond à vos besoins, les chances sont que vous trouviez ce que vous cherchez dans *stringi*.


---
## Des fonctions qui commence par `str_`

.pull-left[

*   `str_c`
*   `str_conv`
*   `str_count`         
*   `str_detect`      
*   `str_dup`      
*   `str_ends`
*   `str_extract` et `str_extract_all` 
*   `str_flatten`     
*   `str_glue`        
*   `str_glue_data`   
*   `str_interp`      
*   `str_length`     
*   `str_locate` et `str_locate_all`  
*   `str_match` et `str_match_all`   
*   `str_order`       
*   `str_pad`         
*   `str_remove` et `str_remove_all`  
*   `str_replace` et `str_replace_all`
]

.pull-right[

*   `str_replace_na`  
*   `str_sort`        
*   `str_split`       
*   `str_split_fixed`
*   `str_squish`      
*   `str_starts`      
*   `str_sub`         
*   `str_sub<-`       
*   `str_subset`      
*   `str_to_lower` et `str_to_upper`  
*   `str_to_sentence`
*   `str_to_title`    
*   `str_trim`        
*   `str_trunc`       
*   `str_view` et `str_view_all`    
*   `str_which`      
*   `str_wrap`     
]



Fonction non présenté
*   "word"      
*   "invert_match"

Data set 
"fruit"
"sentences"
"words" 


---
class: inverse center middle

# Exploration et nettoyage des données


---
### Exploration des chaînes de caractères

La fonction `str_length` pour évaluer la longueur d'une chaine de caractères
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", NA)

str_length(x)

# Base R
nchar(x)

```

---
### Pour gérer les majuscules et les minuscules

*stringr* dispose de quatre fonctions pour nous aider à convertir les majuscules et les minuscules.

<br /> 

La fonction `str_to_upper` pour mettre tous les caractères en majuscule

```{r eval=TRUE}
x <- c("lEs dOnNéEs pArLeNt d'ElLeS-MêMeS")

str_to_upper (x)

```

---
### Pour gérer les majuscules et les minuscules

*stringr* dispose de quatre fonctions pour nous aider à convertir les majuscules et les minuscules.

<br /> 

La fonction `str_to_lower` pour mettre tous les caractères en minuscule

```{r eval=TRUE}
x <- c("lEs dOnNéEs pArLeNt d'ElLeS-MêMeS")

str_to_lower (x)

```

---
### Pour gérer les majuscules et les minuscules

*stringr* dispose de quatre fonctions pour nous aider à convertir les majuscules et les minuscules.

<br /> 

La fonction `str_to_sentence` pour mettre une majuscule au début de la phrase

```{r eval=TRUE}
x <- c("lEs dOnNéEs pArLeNt d'ElLeS-MêMeS")

str_to_sentence (x)

```

---
### Pour gérer les majuscules et les minuscules

*stringr* dispose de quatre fonctions pour nous aider à convertir les majuscules et les minuscules.

<br /> 

La fonction `str_to_title` pour mettre des majuscules dans un titre

```{r eval=TRUE}
x <- c("lEs dOnNéEs pArLeNt d'ElLeS-MêMeS")

str_to_title(x)
```

---
### Pour gérer les majuscules et les minuscules

####Astuce
Chaque langague comporte ces propres particularités. Afin de permettre à R d'exécuter correctement les manipulations demandées, l'argument `locale` permet d'indiquer la langue des caractères. Par défaut, les fonctions de *stringr* utilise "en" pour anglais

Par exemple dans l'alphabet hawaiian, le *e* vient avec le *b*.
```{r eval=TRUE}
x <- c("apple", "eggplant", "banana")

str_sort(x, locale = "en")  # En anglais

str_sort(x, locale = "haw") # En hawaiian
```

---
### Pour extraire ou remplacer des caractères
La fonction `str_sub` pour extraire une partie des caractères. Cette fonction est composée de trois arguments, soit le vecteur, la position de départ et la position de fin

```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", NA)

# Le 3e caractère
str_sub(x, 3, 3)

# Du 2e caractère à l'avant dernière caractère
str_sub(x, 2, -2)

```

---
### Pour extraire ou remplacer des caractères

La fonction `str_sub` peut aussi être utilisée pour modifier un caractère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", NA)

# Remplacer le troisième caractère par un point d'interrogation
str_sub(x, 3, 3) <- "?"
x
```

---
### Pour combiner des caractères

La fonction `str_c` permette de combiner des caractères

```{r eval=TRUE}
str_c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune")
```

<br /> 

En ajoutant l'argument `sep`, on indique par quoi séparer les caractères
```{r eval=TRUE}
str_c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", sep = " et ")
```


---
class: inverse center middle

# À la recherche de *pattern*

---
### Les expressions régulières

Les **expressions régulières** (ou *regexps*) permettent de décrire un *pattern* qui apparait dans une chaîne de caractère.

La *cheat sheet* du *package stringr* présente un bon résumé des différents concepts liés aux expressions régulières.

![](regex.png)

---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_detect` permet de savoir si des chaînes de caractères répondent au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

str_detect(x, "[aeiou]")
```

---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_count` permet de compter combien de caractères répondent au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

str_count(x, "[aeiou]")
```

---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_subset` permet d'extraire les chaînes de caractères répondent au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

str_subset(x, "[aeiou]")
```


---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_locate` permet d'obtenir la position premier caractère qui répond au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

str_locate(x, "[aeiou]")
```



---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_extract` permet d'extraire le premier caractère qui répond au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

str_extract(x, "[aeiou]")
```

---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_match` permet d'extraire des parties de caractères qui correspondent au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

# Extraire les caractères de chaque côté des voyelles
str_match(x, "(.)[aeiou](.)")
```

---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_replace` permet de remplacer les caractères qui répondent au critère
```{r eval=TRUE}
x <- c("mercure", "vénus", "terre", "mars", "jupiter", "saturne", "uranus", "neptune", "why")

str_replace(x, "[aeiou]", "?")
```

---
### Détecter des *patterns*

Les fonctions qui intégre les expressions régulières ont toutes la même structure `str_...(x, pattern)`

<br /> 

La fonction `str_split` permet de séparer les chaînes de caractère
```{r eval=TRUE}
x <- c("mercure, vénus, terre, mars, jupiter, saturne, uranus, neptune")

str_split(x, ", ")
```



---
### Base R contre stringr

R . On reproche toutefois à 
Bien que R offre un ensemble de fonctions pour travailler avec les chaînes de caractères, on reproche aux fonctions de base R de manquer de cohérence et d'être plus difficile à apprendre. 

---
name: colors

## Colors

.left-column[
Text color

[Link Color](#3)

**Bold Color**

_Italic Color_

`Inline Code`
]

.right-column[
Lorem ipsum dolor sit amet, [consectetur adipiscing elit (link)](#3), 
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
Erat nam at lectus urna.
Pellentesque elit ullamcorper **dignissim cras tincidunt (bold)** lobortis feugiat. 
_Eros donec ac odio tempor_ orci dapibus ultrices. 
Id porta nibh venenatis cras sed felis eget velit aliquet.
Aliquam id diam maecenas ultricies mi.
Enim sit amet 
`code_color("inline")`
venenatis urna cursus eget nunc scelerisque viverra.
]

---

# Big Topic or Inverse Slides `#`

## Slide Headings `##`

### Sub-slide Headings `###`

#### Bold Call-Out `####`

This is a normal paragraph text. Only use header levels 1-4.

##### Possible, but not recommended `#####`

###### Definitely don't use h6 `######`

---

# Left-Column Headings

.left-column[
## First

## Second

## Third
]

.right-column[
Dolor quis aptent mus a dictum ultricies egestas.

Amet egestas neque tempor fermentum proin massa!

Dolor elementum fermentum pharetra lectus arcu pulvinar.
]

---
class: inverse center middle

# Topic Changing Interstitial

--

```
class: inverse center middle
```

---
layout: true

## Blocks

---

### Blockquote

> This is a blockquote following a header.
>
> When something is important enough, you do it even if the odds are not in your favor.

---

### Code Blocks

#### R Code


#### JavaScript

```js
var fun = function lang(l) {
  dateformat.i18n = require('./lang/' + l)
  return true;
}
```

---

### More R Code

```{r eval=FALSE}
dplyr::starwars %>% dplyr::slice_sample(n = 4)
```

---

```{r message=TRUE, eval=requireNamespace("cli", quietly = TRUE)}
cli::cli_alert_success("It worked!")
```

--

```{r message=TRUE}
message("Just a friendly message")
```

--

```{r warning=TRUE}
warning("This could be bad...")
```

--

```{r error=TRUE}
stop("I hope you're sitting down for this")
```


---
layout: true

## Tables

---
exclude: `r if (requireNamespace("tibble", quietly=TRUE)) "false" else "true"`

```{r eval=requireNamespace("tibble", quietly=TRUE)}
tibble::as_tibble(mtcars)
```

---

```{r}
knitr::kable(head(mtcars), format = 'html')
```

---
exclude: `r if (requireNamespace("DT", quietly=TRUE)) "false" else "true"`

```{r eval=requireNamespace("DT", quietly=TRUE)}
DT::datatable(head(mtcars), fillContainer = FALSE, options = list(pageLength = 4))
```

---
layout: true

## Lists

---

.pull-left[
#### Here is an unordered list:

*   Item foo
*   Item bar
*   Item baz
*   Item zip
]

.pull-right[

#### And an ordered list:

1.  Item one
1.  Item two
1.  Item three
1.  Item four
]

---

### And a nested list:

- level 1 item
  - level 2 item
  - level 2 item
    - level 3 item
    - level 3 item
- level 1 item
  - level 2 item
  - level 2 item
  - level 2 item
- level 1 item
  - level 2 item
  - level 2 item
- level 1 item

---

### Nesting an ol in ul in an ol

- level 1 item (ul)
  1. level 2 item (ol)
  1. level 2 item (ol)
    - level 3 item (ul)
    - level 3 item (ul)
- level 1 item (ul)
  1. level 2 item (ol)
  1. level 2 item (ol)
    - level 3 item (ul)
    - level 3 item (ul)
  1. level 4 item (ol)
  1. level 4 item (ol)
    - level 3 item (ul)
    - level 3 item (ul)
- level 1 item (ul)

---
layout: true

## Plots

---

```{r plot-example, eval=requireNamespace("ggplot2", quietly=TRUE)}
library(ggplot2)
(g <- ggplot(mpg) + aes(hwy, cty, color = class) + geom_point())
```

---

```{r plot-example-themed, eval=requireNamespace("ggplot2", quietly=TRUE)}
#g + xaringanthemer::theme_xaringan(text_font_size = 16, title_font_size = 18) +
 # ggtitle("A Plot About Cars")
```

---
layout: false

## Square image

<center><img src="https://octodex.github.com/images/labtocat.png" height="400px" /></center>

.footnote[GitHub Octocat]

---

### Wide image

![](https://guides.github.com/activities/hello-world/branching.png)

.footnote[Wide images scale to 100% slide width]

---

## Two images


]

.pull-right[
![](https://octodex.github.com/images/dinotocat.png)
]

---

### Definition lists can be used with HTML syntax.

<dl>
<dt>Name</dt>
<dd>Godzilla</dd>
<dt>Born</dt>
<dd>1952</dd>
<dt>Birthplace</dt>
<dd>Japan</dd>
<dt>Color</dt>
<dd>Green</dd>
</dl>

---
class: center, middle

# Merci!

Slides created via the R packages:

[**xaringan**](https://github.com/yihui/xaringan)<br>
[gadenbuie/xaringanthemer](https://github.com/gadenbuie/xaringanthemer)

The chakra comes from [remark.js](https://remarkjs.com), [**knitr**](http://yihui.name/knitr), and [R Markdown](https://rmarkdown.rstudio.com).
